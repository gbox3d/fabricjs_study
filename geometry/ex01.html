<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>ex01</title>
    <script src="../node_modules/fabric/dist/fabric.js"></script>

    <style>
        .hide {
            display: none;
        }
    </style>
</head>

<body>

    <canvas id="main-canvas" width="512" height="512"></canvas>

    <script type="module">

        const fbCanvas = new fabric.Canvas('main-canvas', {
            backgroundColor: '#000',
            enableRetinaScaling: false //레티나 비활성화
        })

        document.addEventListener('keydown', (evt) => {
            console.log(evt)
            switch(evt.key) {
                case 'q': //정점 정보 리스팅
                console.log(polygon.points)
                break;

                case 'w': //정점 추가 
                polygon.points.push({
                    x: 32, y: 32
                })
                setupEdit(polygon)
                fbCanvas.requestRenderAll();
                break;

                case 'e': //정점 절대 좌표구하기 
                {
                    let absolutePoint = fabric.util.transformPoint({
                        x: (polygon.points[0].x - polygon.pathOffset.x),
                        y: (polygon.points[0].y - polygon.pathOffset.y),
                    }, polygon.calcTransformMatrix())

                    console.log(absolutePoint)
                }
                
                break;
            }
        })

        var points = [{
            x: 0, y: 0
        }, {
            x: 128, y: 0
        },
        {
            x: 96, y: 64
        }
            , {
            x: 0, y: 128
        }]

        var polygon = new fabric.Polygon(points, {
            left: 100,
            top: 50,
            fill: 'transparent',
            strokeWidth: 2,
            stroke: '#ffff00',
            //scaleX: 4,
            //scaleY: 4,
            objectCaching: false,
            transparentCorners: false,
            cornerColor: 'blue',
        });
        fbCanvas.add(polygon)

        // define a function that can locate the controls.
        // this function will be used both for drawing and for interaction.
        function polygonPositionHandler(dim, finalMatrix, fabricObject) {
            var x = (fabricObject.points[this.pointIndex].x - fabricObject.pathOffset.x),
                y = (fabricObject.points[this.pointIndex].y - fabricObject.pathOffset.y);
            return fabric.util.transformPoint(
                { x: x, y: y },
                fabric.util.multiplyTransformMatrices(
                    fabricObject.canvas.viewportTransform,
                    fabricObject.calcTransformMatrix()
                )
            );
        }

        // define a function that will define what the control does
        // this function will be called on every mouse move after a control has been
        // clicked and is being dragged.
        // The function receive as argument the mouse event, the current trasnform object
        // and the current position in canvas coordinate
        // transform.target is a reference to the current object being transformed,
        function actionHandler(eventData, transform, x, y) {
            var polygon = transform.target,
                currentControl = polygon.controls[polygon.__corner],
                mouseLocalPosition = polygon.toLocalPoint(new fabric.Point(x, y), 'center', 'center'),
                polygonBaseSize = polygon._getNonTransformedDimensions(),
                size = polygon._getTransformedDimensions(0, 0),
                finalPointPosition = {
                    x: mouseLocalPosition.x * polygonBaseSize.x / size.x + polygon.pathOffset.x,
                    y: mouseLocalPosition.y * polygonBaseSize.y / size.y + polygon.pathOffset.y
                };
            polygon.points[currentControl.pointIndex] = finalPointPosition;
            return true;
        }

        // define a function that can keep the polygon in the same position when we change its
        // width/height/top/left.
        function anchorWrapper(anchorIndex, fn) {
            return function (eventData, transform, x, y) {
                var fabricObject = transform.target,
                    absolutePoint = fabric.util.transformPoint({
                        x: (fabricObject.points[anchorIndex].x - fabricObject.pathOffset.x),
                        y: (fabricObject.points[anchorIndex].y - fabricObject.pathOffset.y),
                    }, fabricObject.calcTransformMatrix()),
                    actionPerformed = fn(eventData, transform, x, y),
                    newDim = fabricObject._setPositionDimensions({}),
                    polygonBaseSize = fabricObject._getNonTransformedDimensions(),
                    newX = (fabricObject.points[anchorIndex].x - fabricObject.pathOffset.x) / polygonBaseSize.x,
                    newY = (fabricObject.points[anchorIndex].y - fabricObject.pathOffset.y) / polygonBaseSize.y;
                fabricObject.setPositionByOrigin(absolutePoint, newX + 0.5, newY + 0.5);
                return actionPerformed;
            }
        }


        function setupEdit(object) {
            // clone what are you copying since you
            // may want copy and paste on different moment.
            // and you do not want the changes happened
            // later to reflect on the copy.
            var poly = object
            //fbCanvas.setActiveObject(poly);

            var lastControl = poly.points.length - 1;
            poly.cornerStyle = 'circle';
            poly.cornerColor = 'rgba(0,0,255)';
            poly.controls = poly.points.reduce(function (acc, point, index) {
                acc['p' + index] = new fabric.Control({
                    positionHandler: polygonPositionHandler,
                    actionHandler: anchorWrapper(index > 0 ? index - 1 : lastControl, actionHandler),
                    actionName: 'modifyPolygon',
                    pointIndex: index
                });
                return acc;
            }, {});

            poly.hasBorders = false;
        }

        setupEdit(polygon)

        fbCanvas.setActiveObject(polygon)
        fbCanvas.requestRenderAll()
        

    </script>




</body>

</html>